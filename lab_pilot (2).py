# -*- coding: utf-8 -*-
"""Lab_pilot.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11lWE9RTWpGV85zLwYKJ8u_Hqz1xE__Ll

**CÓDIGO PARA REPRESENTAR UN SOLO CONJUNTO DE DATOS**
"""

import matplotlib.pyplot as plt #libreria para hacer los gráficos
import pandas as pd   #libreria para acceder a archivos de excel, manipulación de datos etc
import numpy as np
from scipy.stats import linregress #para hacer regresiones lineales


#AJUSTES DE LOS DATOS--------------------------------------------------------------------------------------------------

archivo_excel='/content/P6_rao carrega masa (12).xlsx' #aquí hay que indicar la ruta del archivo al que \
# queremos que vaya el programa (hay que colgarlo en los archivos del google colab y copiar ruta dando a los 3 puntitos )

#indicamos las casillas que queramos que utilice. ordenadas como: (x,y,u_x,u_y)

columns=(13,14,15,16) #tener en cuenta que se empieza a contar desde 0

rows_range=slice(96,100) #tener en cuenta que se empieza a contar desde 0 y HAY QUE PONER UNA FILA MENOS PARA QUE COJA EL PRIMER PUNTO

#creamos un 'dataframe'= lugar de pandas donde se almacenan los datos tabulados que coja la info que queremos.
#  skiprows se salta las filas hasta llegar a la primera que indiquemos
# nrows y usecols le dice que lea las filas/columnas que le hemos pedido

df=pd.read_excel(archivo_excel, usecols=columns,nrows=rows_range.stop-rows_range.start, skiprows=rows_range.start)

print(df.to_string(index=False)) #como df pone un indice de filas por defecto, se lo quitamos

#ahora, queremos graficar por ejemplo indicando columna A (0) en X y columna B (1) en Y
ax=df.plot(x=df.columns[0], y=df.columns[1], kind='scatter', color='k', label='Punts experimentals')


#AJUSTES DEL GRÁFICO-------------------------------------------------------------------------------------------------

# NOMBRE DE LOS EJES------------------------------
ax.set_ylabel("$R^2$ ($m^2$)", color="black")
ax.set_xlabel("$V_a$ (V)", color="black")

#COLOR DE LOS EJES--------------------------------
ax.spines['bottom'].set_color('black')
ax.spines['top'].set_color('black')
ax.spines['left'].set_color('black')
ax.spines['right'].set_color('black')

# EXTREMOS DE LOS EJES----------------------------
#EJE X
left_lim=1000
right_lim=df[df.columns[0]].max()+1000 # Límite izquierdo en 0, derecho en máximo de los valores + 1
#print(right_lim)
ax.set_xlim(left=left_lim, right=right_lim)
#EJE Y
bottom_lim=0.005
top_lim=df[df.columns[1]].max() + 0.001
ax.set_ylim(bottom=bottom_lim, top=top_lim)
#print(top_lim)

#ESPACIADO DE TICKS------------------------------------
# Espaciado entre ticks
espaciado_en_x = 1000
espaciado_en_y = 0.0025

#np.arange es una función de la biblioteca NumPy que se utiliza para crear secuencias de números espaciados uniformemente.
#numpy.arange([start, ]stop, [step, ], dtype=None)
#start: Valor inicial de la secuencia.
#stop: Valor final de la secuencia. El valor final no está incluido.
#step: Espaciado entre los valores. Es opcional y su valor por defecto es 1.
#dtype: Tipo de datos de los elementos en la secuencia. Es opcional.

ticks_en_x = np.arange(left_lim, right_lim + espaciado_en_x, espaciado_en_x)
ticks_en_y = np.arange(bottom_lim, top_lim + espaciado_en_y, espaciado_en_y)

ax.set_xticks(ticks_en_x)
ax.set_yticks(ticks_en_y)

# PONER TICKS-------------------------------------------
# axis: Puede ser 'x', 'y' o 'both', y determina a cuál de los ejes se aplicarán los cambios.
#which: Puede ser 'major' (ticks principales), 'minor' (ticks secundarios) o 'both'.
#direction: Puede ser 'in', 'out' o 'inout', y determina la dirección de los ticks.
#length: Longitud de los ticks en puntos.
#width: Grosor de los ticks en puntos.
#color: Color de los ticks
#top/bottom=True : que se pongan arriba y abajo los ticks
#left/right=True : que se pongan izq y der  los ticks
#label..=TRU : que se pongan los numeros arriba/abajo/izq/der

ax.tick_params(axis='x', which='both', top=True, bottom=True, labeltop=False, labelbottom=True, direction='in', length=5, width=1, color='black')
ax.tick_params(axis='y', which='both', left=True, right=True, labelleft=True, labelright=False, direction='in', length=5, width=1, color='black')

#FORMATEO PARA UTILIZAR COMA DECIMAL Y NOTACION CIENTIFICA ------------------------------
def format_comma(x, pos):
    if x==0:  # Si el número es menor que tal, aplicamos notación científica
        return 0
    if np.abs(x)<1000:
        return "{:,.3f}".format(x).replace(".", ",").replace('e','E')
        #return"{:,.0f}".format(x).replace(",",".")
    else:  # Para números mayores o iguales a 1, simplemente agregamos la coma decimal
        return "{:,.0f}".format(x).replace(",", ".")

# Formatear los números en los ejes con coma como separador decimal
formatter = plt.FuncFormatter(format_comma)
#ax.xaxis.set_major_formatter(formatter)
ax.yaxis.set_major_formatter(formatter)

#CUADRICULA---------------------------------------------
ax.grid(True, which='both', linestyle='--', linewidth=0.8, color='gray', alpha=0.7)

#REGRESSION LINEAL-----------------------------------------
# Ajustar una regresión lineal
slope, intercept, r_value, p_value, std_err = linregress(df[df.columns[0]], df[df.columns[1]]) #std_err es incertesa del pendent

# Calcular el coeficiente de determinación (R^2)
r_squared = r_value**2

# Crear la ecuación de la recta
ecuacion_recta = f'Equació de la recta: y = {slope:.6f}x + {intercept:.6f}'

#Calcular error en m y b
n = len(df[df.columns[0]])
std_err_intercept = std_err * np.sqrt((1/n) + (np.mean(df[df.columns[0]])**2) / sum((df[df.columns[0]] - np.mean(df[df.columns[0]]))**2))

# Imprimir los resultados
print(f'R^2: {r_squared:.6f}')
print(ecuacion_recta)
print(f'Incertesa pendent: {std_err:.6f}')
print(f'Incertesa tall en Y: {std_err_intercept:.6f}')

# Graficar la regresión lineal
x_recta = np.linspace(df[df.columns[0]].min(), df[df.columns[0]].max(), 100)
y_recta= slope * x_recta + intercept
plt.plot(x_recta, y_recta, color='c', label='Regressió lineal')

#BARRAS DE ERROR----------------------------------------------
#fmt='none': No dibujar puntos de datos, solo las barras de error. 'none' indica que no se mostrarán marcadores en los puntos de datos.
#ecolor='red': Color de las barras de error.
#capsize=5: Longitud de las líneas en los extremos de las barras de error.

plt.errorbar(df[df.columns[0]], df[df.columns[1]], xerr=df[df.columns[2]], yerr=df[df.columns[3]], fmt='none', ecolor='k', capsize=2, label='Incertesa')


#EXTRAS--------------------------
#plt.vlines(0,bottom_lim, top_lim+2, colors='orange',linestyles='--',label='$T=0°C$')

#INDICAR TEXTO EN UN PUNTO---------------------------------------
#row_point = df.iloc[0] #esto selecciona la fila del dataframe
#ax.annotate('Primer punto',
#            xy=(row_point[df.columns[0]], row_point[df.columns[1]]),  # Coordenadas del punto xy=(x,y)
#            xytext=(row_point[df.columns[0]] + 40, row_point[df.columns[1]] ),  # Coordenadas del texto
#            arrowprops=dict(facecolor='black', arrowstyle='->'))

#DEFINIR UNA FUNCIÓN PARA PLOTARLA-----------------------------
mu_0=4*(np.pi)*(10**(-7))
I=1
z=np.linspace(-0.1,0.1,100)
N=300
R=(0.026)/2
L=0.16
f= lambda z: ((mu_0*I*N)/(2*L)) * ( ((z+(L/2)) / (np.sqrt( R**2 + (z+(L/2))**2 ))) - ( (z-(L/2))/(np.sqrt(R**2 + (z-(L/2))**2 )) ) )
B = f(z)
# Graficar f(N)
#plt.plot(z, B, label='$B_{teòric}(z)$',color='m')

plt.legend()
plt.plot()
#podemos guardar el grafico con el nombre que queramos, se guardará en sample_data
plt.savefig("P6_R_VS_Va_HIP.png")

"""**CÓDIGO PARA REPRESENTAR UNA FUNCIÓN Y PLOTARLA**"""

#DEFINIR UNA FUNCIÓN PARA PLOTARLA-----------------------------
mu_0=4*np.pi*10**(-7)
I=1
z=np.linspace(-0.1,0.1,100)
N=[300,75,150]
R=0.026/2
L=0.16
F=[]
for N in N:
  f= lambda z: (mu_0*I*N/2*L)*( (z+L/2)/np.sqrt( R**2 + (z+L/2)**2 ) - (z-L/2)/np.sqrt(R**2 + (z-L/2)**2 ) )
  print(f)
  B = f(z)
  print(f(0))
  plt.plot(z, B, label='$B=\mu_0 N I/2L \cdot ( (z+L/2)/\sqrt{( R^2 + (z+L/2)^2 )} - (z-L/2)/\sqrt{(R^2 + (z-L/2)^2 )} )$',color='m')


#plt.legend()
plt.plot()

"""**CÓDIGO PARA REPRESENTAR DOS CONJUNTOS DE DATOS EN UN MISMO GRÁFICO**"""

import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
from scipy.stats import linregress

# AJUSTES DE LOS DATOS--------------------------------------------------------------------------------------------------

archivo_excel = '/content/P6_rao carrega masa (11).xlsx'

rows_range=slice(2,5)
# Primer conjunto de datos
columns_primer_conjunto = (16,17,18,19)
df_primer_conjunto = pd.read_excel(archivo_excel, usecols=columns_primer_conjunto, nrows=rows_range.stop-rows_range.start, skiprows=rows_range.start)

# Segundo conjunto de datos
columns_segundo_conjunto = (22,23,24,25)
df_segundo_conjunto = pd.read_excel(archivo_excel, usecols=columns_segundo_conjunto, nrows=rows_range.stop-rows_range.start, skiprows=rows_range.start)

print(df_primer_conjunto.to_string(index=False))
print(df_segundo_conjunto.to_string(index=False))
# AJUSTES DEL GRÁFICO-----------------------------------------------

# Calcular límites (coge los valores del conjunto mayor)
left_lim = 0
right_lim = max(df_primer_conjunto[df_primer_conjunto.columns[0]].max(), df_segundo_conjunto[df_segundo_conjunto.columns[0]].max()) + 0.02
bottom_lim = 0
top_lim = max(df_primer_conjunto[df_primer_conjunto.columns[1]].max(), df_segundo_conjunto[df_segundo_conjunto.columns[1]].max()) + 1e-05

ax = plt.gca()
ax.set_xlim(left=left_lim, right=right_lim)
ax.set_ylim(bottom=bottom_lim, top=top_lim)

# NOMBRE DE LOS EJES------------------------------
ax.set_xlabel("$NI/2R$ ($A/m$)", color="black")
ax.set_ylabel("B(T)", color="black")

#COLOR DE LOS EJES--------------------------------
ax.spines['bottom'].set_color('black')
ax.spines['top'].set_color('black')
ax.spines['left'].set_color('black')
ax.spines['right'].set_color('black')


#ESPACIADO DE TICKS------------------------------------
# Espaciado entre ticks
espaciado_en_x = 0.04
espaciado_en_y = 1e-05

#np.arange es una función de la biblioteca NumPy que se utiliza para crear secuencias de números espaciados uniformemente.
#numpy.arange([start, ]stop, [step, ], dtype=None)
#start: Valor inicial de la secuencia.
#stop: Valor final de la secuencia. El valor final no está incluido.
#step: Espaciado entre los valores. Es opcional y su valor por defecto es 1.
#dtype: Tipo de datos de los elementos en la secuencia. Es opcional.

ticks_en_x = np.arange(left_lim, right_lim + espaciado_en_x, espaciado_en_x)
ticks_en_y = np.arange(bottom_lim, top_lim + espaciado_en_y, espaciado_en_y)

ax.set_xticks(ticks_en_x)
ax.set_yticks(ticks_en_y)

# PONER TICKS-------------------------------------------
# axis: Puede ser 'x', 'y' o 'both', y determina a cuál de los ejes se aplicarán los cambios.
#which: Puede ser 'major' (ticks principales), 'minor' (ticks secundarios) o 'both'.
#direction: Puede ser 'in', 'out' o 'inout', y determina la dirección de los ticks.
#length: Longitud de los ticks en puntos.
#width: Grosor de los ticks en puntos.
#color: Color de los ticks
#top/bottom=True : que se pongan arriba y abajo los ticks
#left/right=True : que se pongan izq y der  los ticks
#label..=TRU : que se pongan los numeros arriba/abajo/izq/der

ax.tick_params(axis='x', which='both', top=True, bottom=True, labeltop=False, labelbottom=True, direction='in', length=5, width=1, color='black')
ax.tick_params(axis='y', which='both', left=True, right=True, labelleft=True, labelright=False, direction='in', length=5, width=1, color='black')

#FORMATEO PARA UTILIZAR COMA DECIMAL Y NOTACION CIENTIFICA ------------------------------
def format_comma(x, pos):
    if x <= 0.001 and x!=0:  # Si el número es menor que tal, aplicamos notación científica
        return "{:,.1e}".format(x).replace(".", ",").replace("e", "E")
    else:  # Para números mayores o iguales a 1, simplemente agregamos la coma decimal
        return "{:,.2f}".format(x).replace(".", ",")

# Formatear los números en los ejes con coma como separador decimal
formatter = plt.FuncFormatter(format_comma)
ax.xaxis.set_major_formatter(formatter)
ax.yaxis.set_major_formatter(formatter)


#PLOT PRIMER CONJUNTO
df_primer_conjunto.plot(x=df_primer_conjunto.columns[0], y=df_primer_conjunto.columns[1], kind='scatter', color='darkblue', label='B(R)', ax=ax)

ax.errorbar(df_primer_conjunto[df_primer_conjunto.columns[0]], df_primer_conjunto[df_primer_conjunto.columns[1]],
             xerr=df_primer_conjunto[df_primer_conjunto.columns[2]], yerr=df_primer_conjunto[df_primer_conjunto.columns[3]],
             fmt='none', ecolor='darkblue', capsize=5, label='Incertesa')

#PLOT SEGUNDO CONJUNTO
df_segundo_conjunto.plot(x=df_segundo_conjunto.columns[0], y=df_segundo_conjunto.columns[1], kind='scatter', color='orange', label='B(N)', ax=ax)

ax.errorbar(df_segundo_conjunto[df_segundo_conjunto.columns[0]], df_segundo_conjunto[df_segundo_conjunto.columns[1]],
             xerr=df_segundo_conjunto[df_segundo_conjunto.columns[2]], yerr=df_segundo_conjunto[df_segundo_conjunto.columns[3]],
             fmt='none', ecolor='orange', capsize=5, label='Incertesa')

#CUADRÍCULA---------------------------------------------------------
ax.grid(True, which='both', linestyle='--', linewidth=0.8, color='gray', alpha=0.7)
plt.legend()

# REGRESIÓN LINEAL-----------------------------------------
# RECTA PRIMER CONJUNTO
slope_primer, intercept_primer, r_value_primer, p_value_primer, std_err_primer = linregress(df_primer_conjunto[df_primer_conjunto.columns[0]], df_primer_conjunto[df_primer_conjunto.columns[1]])
r_squared_primer = r_value_primer**2
ecuacion_recta_primer = f'Ecuación de la recta: y = {slope_primer:.1e}x + {intercept_primer:.1e}'

print(f'R^2 Primer Conjunto: {r_squared_primer:.6f}')
print(ecuacion_recta_primer)
print(f'Incertidumbre en la pendiente Primer Conjunto (std_err_primer): {std_err_primer:.1e}')
#print(f'Incertidumbre en la ordenada al origen Primer Conjunto (std_err_primer): {std_err_primer:.}')

# RECTA SEGUNDO CONJUNTO
slope_segundo, intercept_segundo, r_value_segundo, p_value_segundo, std_err_segundo = linregress(df_segundo_conjunto[df_segundo_conjunto.columns[0]], df_segundo_conjunto[df_segundo_conjunto.columns[1]])
r_squared_segundo = r_value_segundo**2
ecuacion_recta_segundo = f'Ecuación de la recta: y = {slope_segundo:.1e}x + {intercept_segundo:.1e}'

print(f'R^2 Segundo Conjunto: {r_squared_segundo:.6f}')
print(ecuacion_recta_segundo)
print(f'Incertidumbre en la pendiente Segundo Conjunto (std_err_segundo): {std_err_segundo:.1e}')
#print(f'Incertidumbre en la ordenada al origen Segundo Conjunto (std_err_segundo): {std_err_segundo:.4f}')

# PLOTADO RECTAS 1 Y 2--------------------------------------------
x_recta_primer = np.linspace(df_primer_conjunto[df_primer_conjunto.columns[0]].min(), df_primer_conjunto[df_primer_conjunto.columns[0]].max(), 100)
y_recta_primer = slope_primer * x_recta_primer + intercept_primer
plt.plot(x_recta_primer, y_recta_primer, color='darkblue',label='Ajust per B(R)')

x_recta_segundo = np.linspace(df_segundo_conjunto[df_segundo_conjunto.columns[0]].min(), df_segundo_conjunto[df_segundo_conjunto.columns[0]].max(), 100)
y_recta_segundo = slope_segundo * x_recta_segundo + intercept_segundo
plt.plot(x_recta_segundo, y_recta_segundo, color='orange',label='Ajust B(N)')

# PLOTADO LEYENDA, GRID Y GRAPHS
plt.legend()
plt.grid(True, which='both', linestyle='--', linewidth=0.8, color='gray', alpha=0.7)
plt.show()

"""**CÓDIGO PARA PLOTAR VARIOS CONJUNTOS DE DATOS**"""

import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
from scipy.stats import linregress

#AJUSTES DE LOS DATOS------------------------------------------------------------
# Ruta del archivo Excel
archivo_excel = '/content/P5 (5).xlsx'

# Definición de los conjuntos de datos
conjuntos_de_datos = [
    {"columns": (2,3,4,5), "rows_range": slice(5,34), "label": r"Resistència al forn", "color":'red'},
    {"columns": (10,11,12,13), "rows_range": slice(5,20), "label": r"Resistència a prop del nitrogen", "color":'c'}

]


#AJUSTES DE LOS GRÁFICOS------------------------------------------------------------
# Definimos listas para almacenar los valores mínimos y máximos de x e y, empezamos con que son infinito
x_min, x_max = float('inf'), float('-inf')
y_min, y_max = float('inf'), float('-inf')

# Crear la figura y el conjunto de ejes de una tirada
fig, ax = plt.subplots()

# TITULO DE LOS EJES--------------------------------------------------------------
ax.set_xlabel("T (°C)", color="black")
ax.set_ylabel("R ($\Omega$)", color="black")

# 1: AJUSTAMOS LOS LÍMITES DE LOS EJES--------------------------
for conjunto in conjuntos_de_datos:
    df = pd.read_excel(archivo_excel, usecols=conjunto["columns"], nrows=conjunto["rows_range"].stop - conjunto["rows_range"].start, skiprows=conjunto["rows_range"].start)
    x_min = min(x_min, df[df.columns[0]].min())
    x_max = max(x_max, df[df.columns[0]].max())
    y_min = min(y_min, df[df.columns[1]].min())
    y_max = max(y_max, df[df.columns[1]].max())

left=-130
right=320
bottom=40
top=240
ax.set_xlim(left, right)
ax.set_ylim(bottom, top)

# 2: ESPACIADO EN LOS TICKS------------------------------------------------
espaciado_en_x = 30
espaciado_en_y =  20
ticks_en_x = np.arange(left, right+30, espaciado_en_x)
ticks_en_y = np.arange(bottom, top+20, espaciado_en_y)
ax.set_xticks(ticks_en_x)
ax.set_yticks(ticks_en_y)

# 3: CONFIGURACIÓN TICKS
ax.tick_params(axis='x', which='both', top=True, bottom=True, labeltop=False, labelbottom=True, direction='in', length=5, width=1, color='black')
ax.tick_params(axis='y', which='both', left=True, right=True, labelleft=True, labelright=False, direction='in', length=5, width=1, color='black')

# Formateo para utilizar coma decimal
def format_comma(x, pos):
    if x ==0:
        return "{:,.0f}".format(x).replace(".", ",")
    if np.abs(x)<0.3:
        return "{:,.0f}".format(x).replace(".", ",")
    else:
        return "{:,.0f}".format(x).replace(".", ",")

formatter = plt.FuncFormatter(format_comma)
ax.xaxis.set_major_formatter(formatter)
ax.yaxis.set_major_formatter(formatter)

# 4: CUADRÍCULA--------------------------------------------------------------
ax.grid(True, which='both', linestyle='--', linewidth=0.8, color='gray', alpha=0.7)

# 5: GRAFICAR CADA CONJUNTO DE DATOS Y SU REGRESIÓN-------------------------------

for conjunto in conjuntos_de_datos:
    print(df)
    df = pd.read_excel(archivo_excel, usecols=conjunto["columns"], nrows=conjunto["rows_range"].stop - conjunto["rows_range"].start, skiprows=conjunto["rows_range"].start)
    ax.scatter(df[df.columns[0]], df[df.columns[1]], color=conjunto["color"],label=conjunto["label"],s=4)


    # 6: LINEAR REGRESSION-------------

  # Ajustar una regresión lineal
    slope, intercept, r_value, p_value, std_err = linregress(df[df.columns[0]], df[df.columns[1]]) #std_err es incertesa del pendent

    # Calcular el coeficiente de determinación (R^2)
    r_squared = r_value**2

    # Crear la ecuación de la recta
    ecuacion_recta = f'Equació de la recta per {conjunto["label"]}: y = {slope:.6f}x + {intercept:.6f}'

    #Calcular error en m y b
    n = len(df[df.columns[0]])
    std_err_intercept = std_err * np.sqrt((1/n) + (np.mean(df[df.columns[0]])**2) / sum((df[df.columns[0]] - np.mean(df[df.columns[0]]))**2))

    # Imprimir los resultados
    print('Dades per', {conjunto["label"]})
    print(f'R^2: {r_squared:.6f}')
    print(ecuacion_recta)
    print(f'u_m = : {std_err:.6f}')
    print(f'u_b = : {std_err_intercept:.6f}')

    # Graficar la regresión lineal
    x_recta = np.linspace(df[df.columns[0]].min(), df[df.columns[0]].max(), 100)
    y_recta= slope * x_recta + intercept
    ax.plot(x_recta, y_recta, color=conjunto["color"])

    #BARRAS DE ERROR----------------------------------------------
    #fmt='none': No dibujar puntos de datos, solo las barras de error. 'none' indica que no se mostrarán marcadores en los puntos de datos.
    #ecolor='red': Color de las barras de error.
    #capsize=5: Longitud de las líneas en los extremos de las barras de error.
#ecolor=conjunto["color"]
    ax.errorbar(df[df.columns[0]], df[df.columns[1]], xerr=df[df.columns[2]], yerr=df[df.columns[3]], fmt='none',ecolor=conjunto["color"], capsize=2)

plt.legend()
## Crear y mostrar la leyenda en la misma figura (solo para recoger los handles y labels)
handles, labels = ax.get_legend_handles_labels()

# Crear una figura separada para la leyenda
fig_legend = plt.figure()
ax_legend = fig_legend.add_subplot(111)
ax_legend.legend(handles, labels, loc='center')
ax_legend.axis('off')

# Guardar las figuras
fig.savefig("P5_temperatures_TOT.png")
fig_legend.savefig("leyenda_P6_R_VS_Vahip.png")

# Mostrar las figuras
plt.show()

{"columns": (3,4,5,6), "rows_range": slice(49, 53), "label": r"I=0,1A", "color":'red'},
    {"columns": (3,4,5,6), "rows_range": slice(58, 62), "label": r"I=0,2A", "color":'orange'},
    {"columns": (3,4,5,6), "rows_range": slice(67, 71), "label": r"I=0,3A", "color":'yellow'},
    {"columns": (3,4,5,6), "rows_range": slice(76, 80), "label": r"I=0,4A", "color":'green'},
    {"columns": (3,4,5,6), "rows_range": slice(85, 89), "label": r"I=0,5A", "color":'darkblue'},
    {"columns": (3,4,5,6), "rows_range": slice(94, 98), "label": r"I=0,6A", "color":'purple'},
    {"columns": (3,4,5,6), "rows_range": slice(103, 107), "label": r"I=0,7A", "color":'c'},
    {"columns": (3,4,5,6), "rows_range": slice(112, 116), "label": r"I=0,8A", "color":'pink'}

